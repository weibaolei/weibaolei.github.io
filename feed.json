{
    "version": "https://jsonfeed.org/version/1",
    "title": "スポンジ・ボブです",
    "subtitle": "",
    "icon": "http://weiboluo.top/images/favicon.ico",
    "description": "",
    "home_page_url": "http://weiboluo.top",
    "items": [
        {
            "id": "http://weiboluo.top/2023/12/26/dockerContainerMacVlan/",
            "url": "http://weiboluo.top/2023/12/26/dockerContainerMacVlan/",
            "title": "Docker容器使用Macvlan配置网络",
            "date_published": "2023-12-26T10:33:09.000Z",
            "content_html": "<h2 id=\"简单了解macvlan\"><a class=\"anchor\" href=\"#简单了解macvlan\">#</a> 简单了解 Macvlan</h2>\n<div class=\"note primary\">\n<p>macvlan 是一种网络虚拟化技术，它允许在一个物理网络接口上配置多个虚拟网络接口，简单的说 macvlan 类型类似于子接口，但是相对于子接口来说，macvlan 的每个虚拟网络接口都有自己独立的 MAC 地址，并且可以配置上 IP 地址进行通信</p>\n</div>\n<ul>\n<li>查询当前内核是否加载 macvlan 内核<br />\n <figure class=\"highlight bash\"><figcaption><span>查询驱动</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">lsmod | grep macvlan</span><br></pre></td></tr></table></figure><br />\n<ins> 如果没有查询到，则可以手动载入，内核代码路径为 /drivers/net/macvlan.c</ins><br />\n<figure class=\"highlight bash\"><figcaption><span>载入驱动</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">modprobe macvlan</span><br></pre></td></tr></table></figure></li>\n<li>macvlan 四种模式\n<ul>\n<li>vepa 模式：各个子设备直接无法直接通信（可以通过支持端口聚合的交换机通信），可以和外部通信。</li>\n<li>private 模式：和 vepa 模式类似，各个子设备之间无法通信，即使通过支持端口聚合的交换机也不能。</li>\n<li>bridge 模式：各个子设备之间可以通信，通过虚拟桥接模式</li>\n<li>passthru 模式：会接管父设备（网口），父设备不能接收数据包，并且每个父设备只允许存在一个 macvlan 设备</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"通过macvlan实现容器与外部主机通信\"><a class=\"anchor\" href=\"#通过macvlan实现容器与外部主机通信\">#</a> 通过 macvlan 实现容器与外部主机通信</h2>\n<ul>\n<li>\n<p>网卡开启混杂模式</p>\n<p><figure class=\"highlight bash\"><figcaption><span>混杂模式</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">#网卡开启混杂模式</span></span><br><span class=\"line\">ifconfig eno1 promisc</span><br><span class=\"line\"><span class=\"comment\">#网卡关闭混杂模式</span></span><br><span class=\"line\">ifconfig eno1 -promisc</span><br></pre></td></tr></table></figure></p>\n<p><img data-src=\"https://wbl-1302681813.cos.ap-nanjing.myqcloud.com/DockerMacvlan/eno1.jpg\" alt=\"\" title=\"eno1\" /></p>\n</li>\n<li>\n<p>创建 macvlan 网络模式</p>\n<p><figure class=\"highlight bash\"><figcaption><span>创建网络模式</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker network create -d macvlan --subnet=192.168.128.0/24 --gateway=192.168.128.2 -o parent=eth0 -o macvlan_mode=vepa vepamv </span><br></pre></td></tr></table></figure></p>\n<p><ins class=\"dot\">--subnet 为子网掩码 CIDR 格式</ins></p>\n<p><ins class=\"dot\">--gateway 为网关</ins></p>\n<p><ins class=\"dot\">parent 为网卡名称</ins></p>\n</li>\n<li>\n<p>创建两个容器 mac1 与 mac2</p>\n<p><figure class=\"highlight bash\"><figcaption><span>创建容器</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker run -itd --name mac1 --net=vepamv --ip=192.168.128.222 -v /sys/fs/cgroup:/sys/fs/cgroup --privileged=<span class=\"literal\">true</span>  --restart=always  mac:latest /usr/sbin/init</span><br></pre></td></tr></table></figure></p>\n<p>查看存在两 mac 地址</p>\n<p><figure class=\"highlight bash\"><figcaption><span>查看模式信息</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">#查看网络模式信息</span></span><br><span class=\"line\">docker network inspect vepamv</span><br></pre></td></tr></table></figure></p>\n<p><img data-src=\"https://wbl-1302681813.cos.ap-nanjing.myqcloud.com/DockerMacvlan/vepamv.jpg\" alt=\"\" title=\"vepamv\" /></p>\n<p>mac1 与 mac2 容器之间相互无法 ping 通，删除上述网络模式与容器</p>\n</li>\n<li>\n<p>创建 bridge 模式的 macvlan 网络，重新新建 mac1 与 mac2 发现能够相互 ping 通</p>\n</li>\n</ul>\n",
            "tags": [
                "Docker",
                "Docker",
                "Network"
            ]
        },
        {
            "id": "http://weiboluo.top/2023/12/25/dockerNetwork/",
            "url": "http://weiboluo.top/2023/12/25/dockerNetwork/",
            "title": "Docker网络模式介绍",
            "date_published": "2023-12-25T10:33:09.000Z",
            "content_html": "<h2 id=\"docker网络模式\"><a class=\"anchor\" href=\"#docker网络模式\">#</a> Docker 网络模式</h2>\n<blockquote>\n<p>Docker 安装之后会自动创建三种基本网络，同时 docker 允许用户进行创建自己的网络配置从而使容器网络配置更加灵活</p>\n</blockquote>\n<h3 id=\"前言\"><a class=\"anchor\" href=\"#前言\">#</a> 前言</h3>\n<p>Docker 安装完成后可以使用 docker network ls 命令查询创建的网络模式，结果如下图会自动创建三种网络模式：bridge、host、none</p>\n<p><img data-src=\"https://wbl-1302681813.cos.ap-nanjing.myqcloud.com/DockerNetwork/BaseNetworkConfig.jpg\" alt=\"\" title=\"网络模式\" /></p>\n<p>同时 Docker 在启动时会开启一个虚拟的网桥设备 docker0，并且会为其配置默认的地址 172.17.0.1/16，后续所有的 Docker 容器启动后都会被桥接到 docker0 上面，并自动分配一个 ip 地址，我们可以用 ip addr 命令查询下详情信息</p>\n<p><img data-src=\"https://wbl-1302681813.cos.ap-nanjing.myqcloud.com/DockerNetwork/docker0.jpg\" alt=\"\" title=\"虚拟设备docker0\" /></p>\n<h3 id=\"bridge模式\"><a class=\"anchor\" href=\"#bridge模式\">#</a> bridge 模式</h3>\n<blockquote>\n<p><strong>bridge 网络模式下的容器没有公有 ip，只有宿主机可以访问，而外部主机无法访问，但是可以通过配置 NAT 规则进行访问</strong></p>\n</blockquote>\n<ul>\n<li>\n<p>bridge 模式的实现依赖的是<strong> veth-pair</strong> 技术，veth-pair 可以理解为在宿主机上面创建两个虚拟网络接口，通过技术特性保证无论哪个 veth 接收到网络报文都会传输给另一方</p>\n</li>\n<li>\n<p>如图，Docker Daemon 将 veth0 附加到 docker0 创建的 docker0 设备上，同时将 veth1 添加到 Docker Container 所属的 namespace 上，改名为 eth0</p>\n<p><img data-src=\"https://wbl-1302681813.cos.ap-nanjing.myqcloud.com/DockerNetwork/vethpair.jpg\" alt=\"\" title=\"veth-pair\" /></p>\n</li>\n<li>\n<p>宿主机的网络报文若发往 veth0，则立即会被 eth0 接收，实现宿主机到 Docker Container 网络的联通性；同时，也保证 Docker Container 单独使用 eth0，实现容器网络环境的隔离性</p>\n<p><img data-src=\"https://wbl-1302681813.cos.ap-nanjing.myqcloud.com/DockerNetwork/bridge.jpg\" alt=\"\" title=\"bridge模式\" /></p>\n</li>\n<li>\n<p>bridge 可以很好的实现容器的网络环境隔离，但是此模式下的容器不具有公有 ip, 会导致虚机与外界不能直接进行通信，虽然可以通过 NAT 模式中间代理实现通信，但是多有不便。</p>\n<ul class=\"task-list\">\n<li class=\"task-list-item\"><input type=\"checkbox\" id=\"cbx_0\" disabled=\"true\" /><label for=\"cbx_0\"> &lt;font face=' 黑体 ' color='red'&gt;TODO :NAT 模式介绍学习 &lt;/font&gt;</label></li>\n</ul>\n</li>\n</ul>\n<h3 id=\"host模式\"><a class=\"anchor\" href=\"#host模式\">#</a> host 模式</h3>\n<blockquote>\n<p>host 模式是对 bridge 模式的补充，采用 host 模式的虚机可以直接借用宿主机的 IP 与外界进行通信</p>\n</blockquote>\n<p><img data-src=\"https://wbl-1302681813.cos.ap-nanjing.myqcloud.com/DockerNetwork/host.jpg\" alt=\"\" title=\"host模式\" /></p>\n<p>host 模式会占用宿主机的网络资源与端口资源，同一个端口，比如宿主机的 80 端口，只能被一个服务占用，如果被某个容器占用了，宿主机就不能用，后续的容器也不能用，直到优先抢到 80 端口的服务，停止提供服务（放弃 80 端口）</p>\n<h3 id=\"none模式\"><a class=\"anchor\" href=\"#none模式\">#</a> none 模式</h3>\n<blockquote>\n<p>此模式关闭了容器的网络功能，仅有独自的网络空间（一个空架子），并且该模式不会给容器分配任何网络资源，包括虚拟网卡、路由、防火墙、IP、网关、端口等</p>\n</blockquote>\n<h3 id=\"32剩余模式\"><a class=\"anchor\" href=\"#32剩余模式\">#</a> 3+2 剩余模式</h3>\n<p>除了上面提到的三种可以通 ls 命令查看的模式之外，docker 还支持其余两种模式，分别是 container 与自定义模式</p>\n<ul>\n<li>\n<p>container 模式</p>\n<blockquote>\n<p>它是 bridge 和 host 模式的合体，优先以 bridge 方式启动启动第一个容器，后面的所有容器启动时，均指定网络模式为 container，它们均共享第一个容器的网络资源，除了网络资源，其他资源，容器彼此之间依然是相互隔离的</p>\n</blockquote>\n</li>\n<li>\n<p>自定义模式</p>\n<p>docker 提供了三种自定义网络驱动分别是 bridge、overlay、macvlan，bridge 驱动类似默认的 bridge 网络模式，但增加了一些新的功能，overlay 和 macvlan 是用于创建跨主机网络</p>\n</li>\n</ul>\n<h2 id=\"命令记录\"><a class=\"anchor\" href=\"#命令记录\">#</a> 命令记录</h2>\n<p><figure class=\"highlight shell\"><figcaption><span>命令记录</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta prompt_\"></span></span><br><span class=\"line\"><span class=\"meta prompt_\">#</span><span class=\"language-bash\">查看docker容器的所有网络模式</span></span><br><span class=\"line\">docker network ls</span><br><span class=\"line\"><span class=\"meta prompt_\">#</span><span class=\"language-bash\">查看哪些容器在该网络模式下</span></span><br><span class=\"line\">docker network inspect bridge</span><br><span class=\"line\"><span class=\"meta prompt_\">#</span><span class=\"language-bash\">查询容器网络模式</span></span><br><span class=\"line\">docker inspect &lt;container&gt; | grep NetworkMode</span><br></pre></td></tr></table></figure></p>\n",
            "tags": [
                "Docker",
                "Docker",
                "Network"
            ]
        }
    ]
}